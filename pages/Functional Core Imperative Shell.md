publish:: false

- Casado: I do think it's going to be super interesting to watch how server side rendering vs client side plays out. There are very strong arguments to make on server side, particularly for first page load. But after that, it's not clear, especially if the page is interactive. **I suspect we may just be entering a multi-arch era where the distribution architecture fragments as much as the languages.**
- Dustin: As you acknowledged/hedged, SSR is domain specific â€“ i.e. ecommerce (ebay) and dynamic websites (like MSDN) where time to glass directly impacts usage. Amazon values time to glass so much that they write frameworkless javascript (can't find the source on that, it was a HN comment)
- For enterprise biz apps (medical, pharma, inventory, internal tools etc) the value of SSR does not outweigh the cost in terms of complexity/focus. The dominant factor here is engineering delivery and agility. Facebook dot com newsfeed, for example, is not SSR'ed (on my machine at least - just checked). Outside of SV-100 companies this is even more true.
- You're right, what you labeled "interactive" I think is the same tradeoff as batch vs streaming/reactive. The more reactive you are, and the heavier your write "flux" (write volume per surface area of impacted UI), the less SSR helps you or it even actively damages you.
- There is a path to unifying SSR with streaming (by moving reactive views closer to or even into the query engine to be incrementally maintained adjacent to the reactive query subscriptions) but that is not what silicon valley frontend is excited about today that I am aware of, it's all very "batch" oriented.
-
- Casado: I really think if the answer reduces to "language independent runtime" it's hard to make the case for WASM. It's actually an interesting historical systems questions. Has there ever been a language independent runtime that's taken off? There have been many efforts, from silicon on up. Remember Transmeta? If the answer reduces to "language independent integration with platform libraries" I think that argument is stronger. But then you reduce an entire stack/register virtual machine to basically just language independent resource bindings. And for any sufficiently popular language, those bindings will be native anyway.
- I'm so open to the other side of this discussion. I've just don't seem to grasp it.
- Not to get too ranty here. But I think the "introduce new virtual machine with its own architecture (stack, register or otherwise)" has to date been a failed concept in systems. What has worked is virtualizing an existing hardware interface (e.g. x86 virtualization) but that's much more of a resource sharing and isolation problem. What also has worked is decoupling the language compiler and runtime (Java, Python etc. etc. etc.). But even in that case, the runtimes are incredibly language specific. The opportunity to optimize the runtime with language specific stuff is just too great. Or at least it has been to date.
- Moran: I guess the JVM (Java) and the CLR (C#) fall into that category? Both are mainly used for 1 language each, but the decoupling allows Kotlin to be compatible with Java, for instance
- Not sure how big Kotlin is though, so might be totally irrelevant
- Casado: Yeah, so there have been many attempts. But to my knowledge they simply never have caught on.
- CLR same.
- All the language independent runtimes seem to have failed. I think there is a lesson there .. namely that **you really do need to verticalize between the language the programmer writes, and the hardware instruction set.**
- Dustin: You can layer VMs at a higher abstraction level that targets or is hosted by existing "layer 1" platforms (which is not what wasm is doing)
- Dustin: Not sure I follow.
- Dustin: Ethereum VM for example is a distributed VM that is hosted by lower layer platforms, and we are seeing EVM be implemented as a higher compatibility interface hosted by other L1 chains
  > namely that you really do need to verticalize between the language the programmer writes, and the hardware instruction set.
  
  Perhaps cloud-native is the difference; as in a world of distributed compute, network "hardware" isthe dominant thing to remove impedance from not compute
-
- Dustin: Distributed systems today are "functional core imperative shell" which unfortunately simply moves platform complexity from the app layer to the system layer without actually addressing it.
- The functional core is easier to reason about and optimize, so we invest massively making functions run faster in isolation, and the imperative connector glue between infra components is under-invested because it's far more complex to reason about
- This is the problem functional effect systems solve and is the essence of functional programming, which is not about eliminating effects but rather taming them such that rich fabrics of effects can be orchestrated at scale (this is a super contrarian take, opposite of consensus). An example of this is applying effect systems to dom rendering (which IS an emerging consensus or at least there are forward indicators).
- And this reactive approach in opposition with SSR. If your distributed system as a whole is modeled as a holistic data flow DAG or electrical circuit, SSR is a big fat capacitor right in the middle of it, an arbitrary chokepoint which is flattening/batching/damaging the intricate and interwoven flow of data through what is at it's essence, a DAG, an electrical circuit through which datums flow like electrons.
- Verticalizing the PL with the hardware instruction set here directly leads us to a distributed VM